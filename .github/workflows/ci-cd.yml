name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
  DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
  DOCKER_IMAGE: user-service
  DOCKER_TAG: latest

jobs:
  # test:
  #   runs-on: ubuntu-latest
  #   defaults:
  #     run:
  #       working-directory: ./User_Service
  #   steps:
  #     - uses: actions/checkout@v2
      
  #     - name: Debug - Print Working Directory
  #       run: |
  #         pwd
  #         ls -la
  #         echo "Current directory structure:"
  #         tree -a
      
  #     - name: Set up Node.js
  #       uses: actions/setup-node@v2
  #       with:
  #         node-version: '18'
          
  #     - name: Install dependencies
  #       run: npm ci
          
  #     - name: Run tests
  #       run: npm test

  build-and-push:
    # needs: test    # Comentado pois o job de teste está comentado
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      
      - name: Debug - Print Working Directory
        run: |
          pwd
          ls -la
          echo "Docker directory contents:"
          ls -la User_Service/docker/
      
      - name: Login to Docker Hub
        uses: docker/login-action@v1
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
          
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1
          
      - name: Build and push
        uses: docker/build-push-action@v2
        with:
          context: ./User_Service
          file: ./User_Service/docker/Dockerfile.api
          push: true
          tags: ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }}

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Set up kubectl
        uses: azure/setup-kubectl@v1
      
      - name: Set up Helm
        uses: azure/setup-helm@v3
      
      - name: Set up Minikube
        uses: medyagh/setup-minikube@master
      
      - name: Deploy to Minikube
        run: |
          minikube start
          
          # Criar namespace para monitoring
          kubectl create namespace monitoring
          
          # Aplicar configurações do Prometheus e Grafana
          kubectl apply -f kubernetes/prometheus-config.yaml
          kubectl apply -f kubernetes/grafana-dashboards.yaml
          kubectl apply -f kubernetes/grafana-datasource.yaml
          
          # Adicionar repos Helm
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo add grafana https://grafana.github.io/helm-charts
          helm repo update
          
          # Instalar Prometheus com valores customizados
          helm install prometheus prometheus-community/prometheus \
            --namespace monitoring \
            --set server.configMapName=prometheus-config
          
          # Instalar Grafana com valores customizados
          helm install grafana grafana/grafana \
            --namespace monitoring \
            --set datasources."datasources\.yaml".apiVersion=1 \
            --set datasources."datasources\.yaml".datasources[0].name=Prometheus \
            --set datasources."datasources\.yaml".datasources[0].type=prometheus \
            --set datasources."datasources\.yaml".datasources[0].url=http://prometheus-server:80 \
            --set datasources."datasources\.yaml".datasources[0].access=proxy \
            --set datasources."datasources\.yaml".datasources[0].isDefault=true
          
          # Aplicar Watchtower
          kubectl apply -f kubernetes/watchtower-deployment.yaml
          
          # Criar secret do Docker
          kubectl create secret docker-registry docker-credentials \
            --docker-server=https://index.docker.io/v1/ \
            --docker-username=$DOCKER_USERNAME \
            --docker-password=$DOCKER_PASSWORD
          
          # Aplicar recursos do postgres
          kubectl apply -f kubernetes/postgres-deployment.yaml
          kubectl apply -f kubernetes/postgres-service.yaml
          
          # Aplicar recursos da aplicação
          kubectl apply -f kubernetes/deployment.yaml
          kubectl apply -f kubernetes/service.yaml
          
          # Esperar pelos pods com os labels corretos
          echo "Waiting for monitoring tools to be ready..."
          kubectl wait --for=condition=ready pod -l "app.kubernetes.io/name=prometheus" --timeout=300s -n monitoring
          kubectl wait --for=condition=ready pod -l "app.kubernetes.io/name=grafana" --timeout=300s -n monitoring
          
          # Mostrar URLs e senhas
          echo "Getting Grafana admin password..."
          kubectl get secret --namespace monitoring grafana -o jsonpath="{.data.admin-password}" | base64 --decode ; echo
          
          echo "Grafana URL:"
          kubectl port-forward -n monitoring svc/grafana 3000:80 &
          
          echo "Prometheus URL:"
          kubectl port-forward -n monitoring svc/prometheus-server 9090:80 &
          
          # Testar a aplicação
          echo "Testing API endpoints..."
          MINIKUBE_IP=$(minikube ip)
          API_URL="http://$MINIKUBE_IP:30000"
          
          echo "1. Testing registration..."
          REGISTER_RESPONSE=$(curl -s -X POST "$API_URL/api/v1/users/register" \
            -H "Content-Type: application/json" \
            -d '{
              "name": "Test User",
              "email": "test@example.com",
              "password": "Test@123",
              "roles": "user"
            }')
          echo "Register Response: $REGISTER_RESPONSE"
          
          echo "2. Testing login..."
          LOGIN_RESPONSE=$(curl -s -X POST "$API_URL/api/v1/users/login" \
            -H "Content-Type: application/json" \
            -d '{
              "email": "test@example.com",
              "password": "Test@123"
            }')
          echo "Login Response: $LOGIN_RESPONSE"
