name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
  DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
  DOCKER_IMAGE: user-service
  DOCKER_TAG: latest

jobs:
  # test:
  #   runs-on: ubuntu-latest
  #   defaults:
  #     run:
  #       working-directory: ./User_Service
  #   steps:
  #     - uses: actions/checkout@v2
      
  #     - name: Debug - Print Working Directory
  #       run: |
  #         pwd
  #         ls -la
  #         echo "Current directory structure:"
  #         tree -a
      
  #     - name: Set up Node.js
  #       uses: actions/setup-node@v2
  #       with:
  #         node-version: '18'
          
  #     - name: Install dependencies
  #       run: npm ci
          
  #     - name: Run tests
  #       run: npm test

  build-and-push:
    # needs: test    # Comentado pois o job de teste está comentado
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      
      - name: Debug - Print Working Directory
        run: |
          pwd
          ls -la
          echo "Docker directory contents:"
          ls -la User_Service/docker/
      
      - name: Login to Docker Hub
        uses: docker/login-action@v1
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
          
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1
          
      - name: Build and push
        uses: docker/build-push-action@v2
        with:
          context: ./User_Service
          file: ./User_Service/docker/Dockerfile.api
          push: true
          tags: ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }}

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Set up kubectl
        uses: azure/setup-kubectl@v1
      
      - name: Set up Helm
        uses: azure/setup-helm@v3
      
      - name: Set up Minikube
        uses: medyagh/setup-minikube@master
      
      - name: Deploy to Minikube
        run: |
          minikube start
          
          # Criar namespace para monitoring
          kubectl create namespace monitoring
          
          # Aplicar configurações do Prometheus e Grafana
          kubectl apply -f kubernetes/prometheus-config.yaml
          kubectl apply -f kubernetes/grafana-dashboards.yaml
          kubectl apply -f kubernetes/grafana-datasource.yaml
          
          # Adicionar repos Helm
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo add grafana https://grafana.github.io/helm-charts
          helm repo update
          
          # Instalar Prometheus e Grafana
          helm install prometheus prometheus-community/prometheus --namespace monitoring
          helm install grafana grafana/grafana --namespace monitoring
          
          # Aplicar outros recursos
          kubectl apply -f kubernetes/watchtower-deployment.yaml
          kubectl create secret docker-registry docker-credentials \
            --docker-server=https://index.docker.io/v1/ \
            --docker-username=$DOCKER_USERNAME \
            --docker-password=$DOCKER_PASSWORD
          kubectl apply -f kubernetes/postgres-deployment.yaml
          kubectl apply -f kubernetes/postgres-service.yaml
          kubectl apply -f kubernetes/deployment.yaml
          kubectl apply -f kubernetes/service.yaml
          
          # Esperar pelos pods
          echo "Waiting for monitoring tools to be ready..."
          kubectl wait --for=condition=ready pod -l "app.kubernetes.io/name=prometheus" --timeout=300s -n monitoring
          kubectl wait --for=condition=ready pod -l "app.kubernetes.io/name=grafana" --timeout=300s -n monitoring
          
          # Mostrar credenciais do Grafana
          echo "Getting Grafana admin password..."
          kubectl get secret --namespace monitoring grafana -o jsonpath="{.data.admin-password}" | base64 --decode ; echo
          
          # Mostrar endpoints
          echo "Endpoints:"
          echo "Grafana: http://localhost:3000"
          echo "Prometheus: http://localhost:9090"
          echo "API: http://$(minikube ip):30000"
          
          # Esperar todos os pods estarem prontos
          kubectl wait --for=condition=ready pod --all --timeout=300s
          
          # Testar a API
          API_URL="http://$(minikube ip):30000"
          echo "Testing API at: $API_URL"
          
          echo "1. Testing registration..."
          curl -v -X POST "$API_URL/api/v1/users/register" \
            -H "Content-Type: application/json" \
            -d '{
              "name": "Test User",
              "email": "test@example.com",
              "password": "Test@123",
              "roles": "user"
            }'

          # Coletar métricas e logs
          echo "=== MONITORING INFORMATION ==="
          
          echo "\n=== Prometheus Metrics ==="
          kubectl port-forward -n monitoring svc/prometheus-server 9090:80 &
          sleep 5
          curl -s http://localhost:9090/api/v1/targets | jq .
          
          echo "\n=== Grafana Status ==="
          kubectl get pods -n monitoring -l "app.kubernetes.io/name=grafana" -o wide
          
          echo "\n=== System Metrics ==="
          kubectl top pods --all-namespaces
          
          echo "\n=== Application Logs ==="
          kubectl logs -l app=user-service --tail=50
          
          echo "\n=== Prometheus Logs ==="
          kubectl logs -n monitoring -l "app.kubernetes.io/name=prometheus" --tail=20
          
          echo "\n=== Grafana Logs ==="
          kubectl logs -n monitoring -l "app.kubernetes.io/name=grafana" --tail=20
          
          echo "\n=== Service Endpoints ==="
          kubectl get services --all-namespaces
          
          echo "\n=== Pod Status ==="
          kubectl get pods --all-namespaces
          
          echo "\n=== Resource Usage ==="
          kubectl describe nodes
          
          # Salvar logs em artifacts
          mkdir -p /tmp/monitoring-logs
          kubectl logs -l app=user-service > /tmp/monitoring-logs/user-service.log
          kubectl logs -n monitoring -l "app.kubernetes.io/name=prometheus" > /tmp/monitoring-logs/prometheus.log
          kubectl logs -n monitoring -l "app.kubernetes.io/name=grafana" > /tmp/monitoring-logs/grafana.log

      - name: Upload monitoring logs
        uses: actions/upload-artifact@v4
        with:
          name: monitoring-logs
          path: /tmp/monitoring-logs
          retention-days: 5
